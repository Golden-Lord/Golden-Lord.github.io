<!DOCTYPE html>
<html>
<head>

	<title>Mope.io Map Idea</title>

	<style type="text/css">
		
		html, body, div, canvas {
		    margin: 0;
		    padding: 0;
		}

	</style>

</head>

<body>


<canvas id='canvas'></canvas>

<script src='jquery-3.1.1.min.js'></script>

<script type="text/javascript">
	

	// wrapper for our game "classes", "methods" and "objects"
	window.Game = {};
	
	// wrapper for "class" Rectangle
	(function(){
		function Rectangle(left, top, width, height){
			this.left = left || 0;
			this.top = top || 0;
            this.width = width || 0;
			this.height = height || 0;
			this.right = this.left + this.width;
			this.bottom = this.top + this.height;
		}
		
		Rectangle.prototype.set = function(left, top, /*optional*/width, /*optional*/height){
			this.left = left;
            this.top = top;
            this.width = width || this.width;
            this.height = height || this.height
            this.right = (this.left + this.width);
            this.bottom = (this.top + this.height);
		}
		
		Rectangle.prototype.within = function(r) {
			return (r.left <= this.left && 
					r.right >= this.right &&
					r.top <= this.top && 
					r.bottom >= this.bottom);
		}		
		
		Rectangle.prototype.overlaps = function(r) {
			return (this.left < r.right && 
					r.left < this.right && 
					this.top < r.bottom &&
					r.top < this.bottom);
		}

		// add "class" Rectangle to our Game object
		Game.Rectangle = Rectangle;
	})();	

	// wrapper for "class" Camera (avoid global objects)
	(function(){
	
		// possibles axis to move the camera
		var AXIS = {
			NONE: "none", 
			HORIZONTAL: "horizontal", 
			VERTICAL: "vertical", 
			BOTH: "both"
		};

		// Camera constructor
		function Camera(xView, yView, canvasWidth, canvasHeight, worldWidth, worldHeight)
		{
			// position of camera (left-top coordinate)
			this.xView = xView || 0;
			this.yView = yView || 0;
			
			// distance from followed object to border before camera starts move
			this.xDeadZone = 0; // min distance to horizontal borders
			this.yDeadZone = 0; // min distance to vertical borders
			
			// viewport dimensions
			this.wView = canvasWidth;
			this.hView = canvasHeight;			
			
			// allow camera to move in vertical and horizontal axis
			this.axis = AXIS.BOTH;	
		
			// object that should be followed
			this.followed = null;
			
			// rectangle that represents the viewport
			this.viewportRect = new Game.Rectangle(this.xView, this.yView, this.wView, this.hView);				
								
			// rectangle that represents the world's boundary (room's boundary)
			this.worldRect = new Game.Rectangle(0, 0, worldWidth, worldHeight);
			
		}

		// gameObject needs to have "x" and "y" properties (as world(or room) position)
		Camera.prototype.follow = function(gameObject, xDeadZone, yDeadZone)
		{		
			this.followed = gameObject;	
			this.xDeadZone = xDeadZone;
			this.yDeadZone = yDeadZone;
		}					
		
		Camera.prototype.update = function()
		{
			// keep following the player (or other desired object)
			if(this.followed != null)
			{		
				if(this.axis == AXIS.HORIZONTAL || this.axis == AXIS.BOTH)
				{		
					// moves camera on horizontal axis based on followed object position
					if(this.followed.x - this.xView  + this.xDeadZone > this.wView)
						this.xView = this.followed.x - (this.wView - this.xDeadZone);
					else if(this.followed.x  - this.xDeadZone < this.xView)
						this.xView = this.followed.x  - this.xDeadZone;
					
				}
				if(this.axis == AXIS.VERTICAL || this.axis == AXIS.BOTH)
				{
					// moves camera on vertical axis based on followed object position
					if(this.followed.y - this.yView + this.yDeadZone > this.hView)
						this.yView = this.followed.y - (this.hView - this.yDeadZone);
					else if(this.followed.y - this.yDeadZone < this.yView)
						this.yView = this.followed.y - this.yDeadZone;
				}						
				
			}		
			
			// update viewportRect
			this.viewportRect.set(this.xView, this.yView);
			
			// don't let camera leaves the world's boundary
			if(!this.viewportRect.within(this.worldRect))
			{
				if(this.viewportRect.left < this.worldRect.left)
					this.xView = this.worldRect.left;
				if(this.viewportRect.top < this.worldRect.top)					
					this.yView = this.worldRect.top;
				if(this.viewportRect.right > this.worldRect.right)
					this.xView = this.worldRect.right - this.wView;
				if(this.viewportRect.bottom > this.worldRect.bottom)					
					this.yView = this.worldRect.bottom - this.hView;
			}
			
		}	
		
		// add "class" Camera to our Game object
		Game.Camera = Camera;
		
	})();

	// wrapper for "class" Player
	(function(){
		function Player(x, y){

			this.x = x;
			this.y = y;				
			
			this.speed = 5;	

			this.velX = 0;
			this.velY = 0;	
			
			this.r = 50;

			this.rotation = 0;

			this.image = new Image();
			this.image.src = 'giraffe.png';
		}
		
		Player.prototype.update = function(worldWidth, worldHeight, xView, yView, mouseX, mouseY){
			
			this.rotation = Math.atan2(mouseX - ( this.x - xView ), -( mouseY - ( this.y - yView ) ));	

			var xDistance = mouseX - ( this.x - xView );
			var yDistance = mouseY - ( this.y - yView );

			var distance = Math.sqrt(xDistance * xDistance + yDistance * yDistance);

			if (distance > this.speed) {
       			xDistance = xDistance * this.speed / distance;
       			yDistance = yDistance * this.speed / distance;
    		}

			this.x += xDistance;
			this.y += yDistance;		
			
			// don't let player leaves the world's boundary
			if(this.x - this.r < 0){
				this.x = this.r;
			}
			if(this.y - this.r < 0){
				this.y = this.r;
			}
			if(this.x + this.r > worldWidth){
				this.x = worldWidth - this.r;
			}
			if(this.y + this.r > worldHeight){
				this.y = worldHeight - this.r;
			}
		}
		
		Player.prototype.draw = function(ctx, xView, yView){		

			var x = this.x - xView;
			var y = this.y - yView;

			ctx.save();

			ctx.translate(x, y);
			ctx.rotate(this.rotation);

			ctx.drawImage(this.image, 0 - this.r, 0 - this.r, this.r * 2, this.r * 2);

			ctx.restore();
			
		}
		
		// add "class" Player to our Game object
		Game.Player = Player;
		
	})();

	// wrapper for "class" Map
	(function(){
		function Map(width, height){
			// map dimensions
			this.width = width;
			this.height = height;
			
			// map texture
			this.image = null;
		}
		
		// generate an example of a large map
		Map.prototype.generate = function(){
			var canvas = document.createElement("canvas");
			var ctx = canvas.getContext("2d");

			canvas.width = this.width;
			canvas.height = this.height;

			var W = this.width,
				H = this.height;		
			
			ctx.save();

			ctx.fillStyle = '#1661ff';
			ctx.fillRect(0, 0, this.width, this.height);


			// green fields biome of circle 1
			ctx.beginPath();
			ctx.arc(W*0.275, H/2, W*0.20, 1.95*Math.PI, 1.05*Math.PI);			
			ctx.fillStyle = '#0afa1b';
			ctx.fill();	

			// forest biome of circle 1
			ctx.beginPath();
			ctx.arc(W*0.275, H/2, W*0.20, 1.05*Math.PI, 1.95*Math.PI);
			ctx.fillStyle = '#04a20e';
			ctx.fill();		

			// savanna biome of circle 2
			ctx.beginPath();
			ctx.arc(W*0.725, H/2, W*0.20, 0.95*Math.PI, 2.05*Math.PI);
			ctx.fillStyle = '#dfff0a';
			ctx.fill();	

			// jungle biome of circle 2
			ctx.beginPath();
			ctx.arc(W*0.725, H/2, W*0.20, 2.05*Math.PI, 0.95*Math.PI);
			ctx.fillStyle = '#118700';
			ctx.fill();	

			// mountain biome
			ctx.beginPath();
			ctx.arc(W/2, H/2, W*0.12, 0, 2*Math.PI);
			ctx.fillStyle = '#949494';
			ctx.fill();		

			// north pole biome
			ctx.beginPath();
			ctx.ellipse(W/2, 0, W/4, H*0.1, 0, 0, 1*Math.PI);
			ctx.fillStyle = '#f3feff';
			ctx.fill();		

			// south pole biome
			ctx.beginPath();
			ctx.ellipse(W/2, H, W/2, H*0.1, 0, 1*Math.PI, 2*Math.PI);
			ctx.fillStyle = '#f3feff';
			ctx.fill();									
			
			// store the generate map as this image texture
			this.image = new Image();
			this.image.src = canvas.toDataURL("image/png");					
			
			// clear context
			ctx = null;
		}
		
		// draw the map adjusted to camera
		Map.prototype.draw = function(context, xView, yView){					
			
			var sx, sy, dx, dy;
            var sWidth, sHeight, dWidth, dHeight;
			
			// offset point to crop the image
			sx = xView;
			sy = yView;
			
			// dimensions of cropped image			
			sWidth =  context.canvas.width;
			sHeight = context.canvas.height;

			// if cropped image is smaller than canvas we need to change the source dimensions
			if(this.image.width - sx < sWidth){
				sWidth = this.image.width - sx;
			}
			if(this.image.height - sy < sHeight){
				sHeight = this.image.height - sy; 
			}
			
			// location on canvas to draw the croped image
			dx = 0;
			dy = 0;
			// match destination with source to not scale the image
			dWidth = sWidth;
			dHeight = sHeight;									
			
			context.drawImage(this.image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);			
		}
		
		// add "class" Map to our Game object
		Game.Map = Map;
		
	})();

	// Game Script
	function game(){
		// prepaire our game canvas
		var canvas = document.getElementById("canvas");
		var context = canvas.getContext("2d");

		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;		

		// game settings:	
		var FPS = 30;
		var INTERVAL = 1000/FPS; // milliseconds
		
		// setup an object that represents the room
		var room = {
			width: 10000,
			height: 7000,
			map: new Game.Map(10000, 7000)
		};

		var mouseX = 0;
		var mouseY = 0;
		
		// generate a large image texture for the room
		room.map.generate();
		 
		// setup player
		var player = new Game.Player( Math.floor((Math.random() * room.width) + 1), Math.floor((Math.random() * room.height) + 1) );
		
		// setup the magic camera !!!
		var camera = new Game.Camera(0, 0, canvas.width, canvas.height, room.width, room.height);		
		camera.follow(player, canvas.width/2, canvas.height/2);
		
		// Game update function
		var update = function(){			
			player.update(room.width, room.height, camera.xView, camera.yView, mouseX, mouseY);
			camera.update();
		}
			
		// Game draw function
		var draw = function(){
			// clear the entire canvas
			context.clearRect(0, 0, canvas.width, canvas.height);
			
			// redraw all objects
			room.map.draw(context, camera.xView, camera.yView);		
			player.draw(context, camera.xView, camera.yView);	

		}
		
		// Game Loop
		var gameLoop = function(){        				
			update();
			draw();
		}

		var int = setInterval(gameLoop, INTERVAL);

		$(window).mousemove(function(event) {

			mouseX = event.pageX;
			mouseY = event.pageY;

		});
		
	}


	// start the game when page is loaded
	window.onload = function(){	
		game();
	}


</script>


</body>
</html>
